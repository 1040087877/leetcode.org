* BFS

* Two-End BFS
** 127
#+begin_src sh :results output :wrap source markdown
cat problems/127.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
给定两个单词（_beginWord_ 和 _endWord_）和一个字典，找到从 _beginWord_ 到 _endWord_ 的最短转换序列的长度。转换需遵循如下规则：

1.  每次转换只能改变一个字母。
2.  转换过程中的中间单词必须是字典中的单词。

,**说明:**

,*   如果不存在这样的转换序列，返回 0。
,*   所有单词具有相同的长度。
,*   所有单词只由小写字母组成。
,*   字典中不存在重复的单词。
,*   你可以假设 _beginWord_ 和 _endWord_ 是非空的，且二者不相同。

,**示例 1:**

,**输入:**
beginWord = "hit",
endWord = "cog",
wordList = \["hot","dot","dog","lot","log","cog"\]

,**输出:** 5

,**解释:** 一个最短转换序列是 "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     返回它的长度 5。

,**示例 2:**

,**输入:**
beginWord = "hit"
endWord = "cog"
wordList = \["hot","dot","dog","lot","log"\]

,**输出:** 0

,**解释:** _endWord_ "cog" 不在字典中，所以无法进行转换。
[https://leetcode-cn.com/problems/word-ladder/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution two\-end bfs/,/^}/{/\@solution two\-end bfs/!p}' solutions/127.*.java
#+end_src

#+RESULTS:
#+begin_source java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> dict = new HashSet<>(wordList), temp = new HashSet<>();
        Set<String> front = new HashSet<>(), back = new HashSet<>();
        if (!dict.contains(endWord)) return 0;
        int step = 1;
        front.add(beginWord);
        back.add(endWord);
        dict.remove(beginWord);
        while(!front.isEmpty() && !back.isEmpty()) {
            if (front.size() > back.size()) { // todo
                temp = front;
                front = back;
                back = temp;
            }
            temp = new HashSet<>();
            for(String word : front) {
                for(int i = beginWord.length() - 1; i >= 0 ; i --) {
                    char[] letters = word.toCharArray();
                    for (char alphabet = 'a'; alphabet <= 'z'; alphabet ++) {
                        if (letters[i] == alphabet) continue;
                        letters[i] = alphabet;
                        String target = String.valueOf(letters);
                        if (back.contains(target)) return step + 1;
                        if (dict.contains(target)) {
                            temp.add(target);
                            dict.remove(target);
                        }
                    }
                }
            }
            front = temp;
            step ++;
        }
        return 0;
    }
}
#+end_source


** 433
#+begin_src sh :results output :wrap source markdown
cat problems/433.*.md
#+end_src

#+RESULTS:
#+begin_source markdown
一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 `"A"`, `"C"`, `"G"`, `"T"`中的任意一个。

假设我们要调查一个基因序列的变化。**一次**基因变化意味着这个基因序列中的**一个**字符发生了变化。

例如，基因序列由`"AACCGGTT"` 变化至 `"AACCGGTA"` 即发生了一次基因变化。

与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。

现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。

,**注意:**

1.  起始基因序列默认是合法的，但是它并不一定会出现在基因库中。
2.  所有的目标基因序列必须是合法的。
3.  假定起始基因序列与目标基因序列是不一样的。

,**示例 1:**

start: "AACCGGTT"
end:   "AACCGGTA"
bank: \["AACCGGTA"\]

返回值: 1

,**示例 2:**

start: "AACCGGTT"
end:   "AAACGGTA"
bank: \["AACCGGTA", "AACCGCTA", "AAACGGTA"\]

返回值: 2

,**示例 3:**

start: "AAAAACCC"
end:   "AACCCCCC"
bank: \["AAAACCCC", "AAACCCCC", "AACCCCCC"\]

返回值: 3
[https://leetcode-cn.com/problems/minimum-genetic-mutation/description/]
#+end_source

#+begin_src sh :results output :wrap source java
sed -n '/\@solution two\-end bfs/,/^}/{/\@solution two\-end bfs/!p}' solutions/433.*.java
#+end_src

#+RESULTS:
#+begin_source java
// todo hashset is better than linkedlist
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        Set<String> dict = new HashSet<>(Arrays.asList(bank)), temp = new HashSet<>();
        Set<String> front = new HashSet<>(), back = new HashSet<>();
        if (!dict.contains(end)) return -1;
        char[] nucleobases = {'A', 'C', 'G', 'T'};
        int step = 0;
        front.add(start);
        back.add(end);
        dict.remove(start);
        while (!front.isEmpty() && !back.isEmpty()) {
            if (front.size() > back.size()) {
                temp = front;
                front = back;
                back = temp;
            }
            temp = new HashSet<>();
            for (String sequence : front) {
                for (int i = sequence.length() - 1; i >= 0; i --) {
                    char[] genes = sequence.toCharArray();
                    for (char base : nucleobases) {
                        if (genes[i] == base) continue;
                        genes[i] = base;
                        String mutation = String.valueOf(genes);
                        if (back.contains(mutation)) return step + 1;
                        if (dict.contains(mutation)) {
                            dict.remove(mutation);
                            temp.add(mutation);
                        }

                    }
                }
            }
            step ++;
            front = temp;
        }
        return -1;
    }
}
#+end_source
